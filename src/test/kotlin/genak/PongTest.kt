/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package genak

import com.github.kittinunf.fuel.httpGet
import com.typesafe.config.ConfigBeanFactory
import com.typesafe.config.ConfigFactory
import config.InfluxCfg
import config.PongCfg
import kotlinx.coroutines.experimental.runBlocking
import org.influxdb.BatchOptions
import org.influxdb.InfluxDB
import org.influxdb.InfluxDBFactory
import org.influxdb.dto.Point
import org.slf4j.LoggerFactory
import org.testng.annotations.AfterClass
import org.testng.annotations.BeforeClass
import org.testng.annotations.Test
import java.util.concurrent.TimeUnit
import java.util.concurrent.atomic.AtomicLong
import kotlin.system.measureTimeMillis


class PongTest {

    val log = LoggerFactory.getLogger(this.javaClass.name)

    val config by lazy { ConfigFactory.load() }
    val influxCfg by lazy { ConfigBeanFactory.create(config.getConfig("influxdb"), InfluxCfg::class.java) }
    val pongCfg by lazy { ConfigBeanFactory.create(config.getConfig("pong"), PongCfg::class.java) }

    val id = AtomicLong(0)
    lateinit var influxDb: InfluxDB

    @BeforeClass
    fun init() {

        influxDb = InfluxDBFactory.connect(influxCfg.url, influxCfg.user, influxCfg.pass)
        influxDb.setDatabase(influxCfg.dbName)
        // Flush every 1000 Points, at least every 2000ms
        influxDb.enableBatch(BatchOptions.DEFAULTS.actions(1000).flushDuration(2000))

//        val query = Query("SELECT idle FROM cpu", dbName)
//        influxDb.query(query)
    }

    @AfterClass
    fun cleanup() {
        influxDb.flush()
        influxDb.close()
    }

    @Test
    fun tst() {
        log.info("begin")
        val totalTime = measureTimeMillis {
            val total = 1_000_000
            spawn(total) {
                wget(id.getAndIncrement())
            }.mapIndexed { i, promise ->
                logProgress(i, total, 10, "promise")
                promise
            }.map {
                runBlocking { it.await() }
            }.mapIndexed { i, fulfilled ->
                val (res, tim) = fulfilled
                logProgress(i, total, 10, "fulfilled")
                influxDb.write(measurement(res, tim))
                fulfilled
            }.count()//.toList()
        }
//
//        val zeroMsCount = results.filter { (res, tim) -> 0L == tim.elapsedMs }.count()
//        val okCount = results.filter { (res, tim) -> res.response.isSuccessful }.count()

        log.info("totalTime {} msec", totalTime)
    }

    inline fun logProgress(i: Int, total: Int, intervals: Int = 100, tag: String = "") {
        if (0 == i % (total / intervals)) {
            log.info("{}: {} / {}", tag, i, total)
        }
    }

    inline fun measurement(result: FuelRes, timings: Timings) =
            Point.measurement("timing")
                    .time(timings.endMs, TimeUnit.MILLISECONDS)
                    .addField("elapsedMs", timings.elapsedMs)
                    .addField("endMs", timings.endMs)
                    .addField("result", result.resolve())
//                .addField("res2",result.component2().toString())
                    .build()

    inline fun url(id: Long) = "${pongCfg.url}/ping/${id}"

    fun wget(id: Long) = FuelRes(url(id).httpGet().responseString())


}

