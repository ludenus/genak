/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package genak

import com.github.kittinunf.fuel.httpGet
import com.typesafe.config.ConfigBeanFactory
import com.typesafe.config.ConfigFactory
import config.InfluxCfg
import config.PongCfg
import kotlinx.coroutines.experimental.runBlocking
import org.influxdb.BatchOptions
import org.influxdb.InfluxDB
import org.influxdb.InfluxDBFactory
import org.slf4j.LoggerFactory
import org.testng.annotations.AfterClass
import org.testng.annotations.BeforeClass
import org.testng.annotations.Test
import java.util.concurrent.atomic.AtomicLong
import kotlin.system.measureTimeMillis


class PongTest {

    val log = LoggerFactory.getLogger(this.javaClass.name)

    val config by lazy { ConfigFactory.load() }
    val influxCfg by lazy { ConfigBeanFactory.create(config.getConfig("influxdb"), InfluxCfg::class.java) }
    val pongCfg by lazy { ConfigBeanFactory.create(config.getConfig("pong"), PongCfg::class.java) }

    val id = AtomicLong(0)
    lateinit var influxDb: InfluxDB

    inline fun url(id: Long) = "${pongCfg.url}/ping/${id}"

    inline fun wget(id: Long) = FuelRes(url(id).httpGet().responseString())


    @BeforeClass
    fun init() {
        influxDb = InfluxDBFactory.connect(influxCfg.url, influxCfg.user, influxCfg.pass)
        influxDb.setDatabase(influxCfg.dbName)
        // Flush every 10001 Points, at least every 10002ms
        influxDb.enableBatch(BatchOptions.DEFAULTS.actions(10001).flushDuration(10002))

//        val query = Query("SELECT idle FROM cpu", dbName)
//        influxDb.query(query)
    }

    @AfterClass
    fun cleanup() {
        influxDb.flush()
        influxDb.close()
    }

    @Test
    fun tst() {
        log.info("begin")
        val total = 100_000
        val totalTime = measureTimeMillis {

            spawnSequence(total) {
                wget(id.getAndIncrement())
            }.mapIndexed { i, promise ->
                // logProgressPart(i, total, "promised", 10)
                // logProgressTime(i, total, "promise", 1000)
                promise
            }.map {
                runBlocking { it.await() }
            }.mapIndexed { i, fulfilled ->
                val (res, tim) = fulfilled
                // logProgressPart(i, total, "fulfilled", 10)
                influxDb.write(measurement(res, tim))
                fulfilled
            }.count()//.toList()
        }
        log.info("totalCount {} totalTime {} msec, rate {} rps ", total, totalTime, total / (totalTime / 1000.0))
    }

}
